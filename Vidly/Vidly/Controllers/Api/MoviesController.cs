using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Web.Http;
using Antlr.Runtime;
using AutoMapper;
using Microsoft.Ajax.Utilities;
using Vidly.Dtos;
using Vidly.Models;
using System.Data.Entity;
using System.IO;

namespace Vidly.Controllers.Api
{
    public class MoviesController : ApiController
    {
        private ApplicationDbContext _context;

        public MoviesController()
        {
            _context = new ApplicationDbContext();
        }

        protected override void Dispose(bool disposing)
        {
            _context.Dispose();
            base.Dispose(disposing);
        }

        //GET /api/movies
        [AllowAnonymous]
        public IHttpActionResult GetMovies(string query = null)
        {
            /*
             * get the list of movies from the context
             * map them to objects of movieDto using select(Auto mapper delegate)
             */

            /*
             * get movies from context , eager load the genres
             * only movies that are available
             * if there's a query string
             * get movies that contains that query and
             */
            var moviesQuery = _context.Movies
                .Include(m => m.Genre)
                .Where(m => m.NumberAvailable > 0);

            if (!string.IsNullOrEmpty(query))
            {
                moviesQuery = moviesQuery.Where(m => m.Name.Contains(query));
            }

            var moviesDto = moviesQuery
                .ToList()
                //didn't put Map() because I'm passing a delegate
                .Select(Mapper.Map<Movie, MovieDto>);
            return Ok(moviesDto);
        }

        //GET api/movies/1
        [AllowAnonymous]
        public IHttpActionResult GetMovie(int id)
        {
            /*
             * get the movie from the context
             * eager load the genre
             * check if it exists , if not return not found
             * else return ok
             * and map the movie object to a movieDto using auto mapper and return it
             */
            var movie = _context.Movies
                .Include(m => m.Genre)
                .SingleOrDefault(m => m.Id == id);
            if (movie == null)
            {
                return NotFound();
            }

            return Ok(Mapper.Map<Movie, MovieDto>(movie));
        }

        //POST /api/movies
        [System.Web.Http.HttpPost]
        [Authorize(Roles = RoleName.CanManageMovies)]
        public IHttpActionResult CreateMovie(MovieDto movieDto)
        {
            /*
             * check if the model is valid
             * if not return bad request
             * map the movieDto to a movie object
             * we set the NumberAvailable property of the movie
             * we set the DateAdded property of the movie
             * we set the genre, to return it in the reply
             * add the movie object to the context and save the changes
             * the movieId is generated by EF so you need to set it to the movieDto because it's zero
             * return Created (requestURI + movieId) movieDto
             */
            if (!ModelState.IsValid)
            {
                return BadRequest();
            }
            //if a stupid user  passed a genre object
            movieDto.Genre = null;

            var movie = Mapper.Map<MovieDto, Movie>(movieDto);
            movie.NumberAvailable = movie.NumberInStock;
            movie.DateAdded = DateTime.Now;

            /*
             * we set the genre, only to return it to the user , Ef tries to insert a new Genre if a genre object is delivered
             * I think it assumes it like this : movie.genre = new genre()
             * NO we need to GET the genre from the database not to create a new object
             */

            movie.Genre = _context.Genres.Single(g => g.Id == movie.GenreId);

            _context.Movies.Add(movie);
            _context.SaveChanges();
            movieDto.Id = movie.Id;
            return Created(new Uri(Request.RequestUri + "/" + movie.Id), movieDto);

            #region Problem

            /* PROBLEM
            * if a genre object is passed like this
            *
            * {
               "name": "G Test",
               "genreId": 4,
               "genre": {
                       "id": 4,
                       "name": "Romance"
                        },
               "releaseDate": "2003-03-03T00:00:00",
               "numberInStock": 3
               }
            *
            * EF assumes it's a new object and tries to create a new Genre object in the database ,
            * which is wrong , we don't change the genres , we only get them from the database
            * so the genre object should be null when posting or putting to the Api
            * however we use the GenreDto only to present the genre object to the user when using the Get method
            *
            * but if a stupid user passed a genre object like I did above
            * I'll set the genre object of the GenreDto to null for such things
            *
            * you still need to do this in the customers Api for membership type
            */

            #endregion Problem
        }

        //PUT /api/movies/1
        [System.Web.Http.HttpPut]
        [Authorize(Roles = RoleName.CanManageMovies)]
        public void UpdateMovie(int id, MovieDto movieDto)
        {
            /*
             * check the model if not valid throw http exception bad request
             * get MovieInDb by id
             * if movie doesn't exist in db throw https exception not found
             * map movieDto to moveInDb
             * save changes
             */
            if (!ModelState.IsValid)
            {
                throw new HttpResponseException(HttpStatusCode.BadRequest);
            }

            var movieInDb = _context.Movies.SingleOrDefault(m => m.Id == id);
            if (movieInDb == null)
            {
                throw new HttpResponseException(HttpStatusCode.NotFound);
            }

            Mapper.Map<MovieDto, Movie>(movieDto, movieInDb);
            _context.SaveChanges();
        }

        //DELETE /api/movies/1

        [System.Web.Http.HttpDelete]
        [Authorize(Roles = RoleName.CanManageMovies)]
        public void DeleteMovie(int id)
        {
            var movieInDb = _context.Movies.SingleOrDefault(m => m.Id == id);
            if (movieInDb == null)
            {
                throw new HttpResponseException(HttpStatusCode.NotFound);
            }
            var movieRentals = _context.Rentals
                .Include(r=>r.Movie)
                .Where(r=>r.Movie.Id == id).ToList();
            foreach (var rental in movieRentals)
            {
                _context.Rentals.Remove(rental);
            }
            _context.SaveChanges();
            _context.Movies.Remove(movieInDb);
            _context.SaveChanges();
            string pic = id.ToString() + ".jpg";
            string path = System.IO.Path.Combine(
                System.Web.HttpContext.Current.Server.MapPath("~/Content/Images/"), pic);
            //he might not have provided an image
            if (File.Exists(path))
            {
                File.Delete(path);
            }
        }
    }
}